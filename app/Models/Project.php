<?php

namespace App\Models;

use App\Http\Controllers\spatialContainer;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;

class Project extends Model
{
    use SoftDeletes;

    protected $table = 'projects';

    protected $fillable = ['name', 'description', 'user_id'];

    protected $appends = ['url', 'project_parameters'];

    private ?spatialContainer $_container = null;

    //Relations
    public function samples(): BelongsToMany
    {
        return $this->belongsToMany(Sample::class);
    }

    public function parameters(): HasMany
    {
        return $this->hasMany(ProjectParameter::class);
    }

    public function genes(): HasMany
    {
        return $this->hasMany(ProjectGene::class);
    }

    //Attributes
    public function getUrlAttribute() {
        return route('open-project', ['project' => $this->id]);
    }

    public function getProjectParametersAttribute() {
        $params = [];
        foreach ($this->parameters as $param)
            $params[$param->parameter] = $param->type === 'number' ? intval($param->value) : $param->value;

        $params['total_genes'] = $this->genes()->count();

        return $params;
    }


    public function getCurrentStepUrl() {
        if($this->current_step === 1)
            return route('import-data', ['project' => $this->id]);

        if($this->current_step === 2)
            return route('qc-data-transformation', ['project' => $this->id]);


        return '/';
    }

    public function workingDir() : string {
        $workingDir = '/users/' . (auth()->id() ?? '9999') . '/' . $this->id . '/';
        $workingDir = str_replace('\\', '/', $workingDir);
        return $workingDir;
    }

    public function workingDirPublic() : string {
        Storage::createDirectory('/public/users');
        Storage::createDirectory('/public/users/' . (auth()->id() ?? '9999'));
        Storage::createDirectory('/public/users/' . (auth()->id() ?? '9999') . '/' . $this->id);
        $workingDir = '/public/users/' . (auth()->id() ?? '9999') . '/' . $this->id . '/';
        $workingDir = str_replace('\\', '/', $workingDir);
        return $workingDir;
    }

    public function workingDirPublicURL() : string {
        $workingDir = '/storage/users/' . (auth()->id() ?? '9999') . '/' . $this->id . '/';
        $workingDir = str_replace('\\', '/', $workingDir);
        return $workingDir;
    }

    public function createStList() {

        $workingDir = $this->workingDir();

        $script = $workingDir . 'STList.R';

        Storage::put($script, $this->getStListScript());

        //Create the initial_stlist
        $this->spatialExecute('Rscript STList.R');

        //Load genes present in samples into the DB
        $genes_file = $workingDir . 'genes.csv';
        if(Storage::fileExists($genes_file)) {
            $data = Storage::read($genes_file);
            $genes = explode("\n", $data);
            $_genes = [];
            foreach ($genes as $gene)
                if(strlen($gene))
                    $_genes[] = ['gene' => $gene, 'project_id' => $this->id];
                //ProjectGene::create(['gene' => $gene, 'project_id' => $this->id]);
            DB::delete('delete from project_genes where project_id=' . $this->id);
            ProjectGene::insert($_genes);
        }

        //Delete previously generated parameters, if any
        DB::delete('delete from project_parameters where project_id=' . $this->id);
        //Load other parameters generated by the R script
        $file = $workingDir . 'max_spot_counts.csv';
        if(Storage::fileExists($file)) {
            $data = trim(Storage::read($file));
            ProjectParameter::insert(['parameter' => 'max_spot_counts', 'type' => 'number', 'value' => $data, 'project_id' => $this->id]);
        }
        $file = $workingDir . 'max_gene_counts.csv';
        if(Storage::fileExists($file)) {
            $data = trim(Storage::read($file));
            ProjectParameter::insert(['parameter' => 'max_gene_counts', 'type' => 'number', 'value' => $data, 'project_id' => $this->id]);
        }
        $file = $workingDir . 'max_spots_number.csv';
        if(Storage::fileExists($file)) {
            $data = trim(Storage::read($file));
            ProjectParameter::insert(['parameter' => 'max_spots_number', 'type' => 'number', 'value' => $data, 'project_id' => $this->id]);
        }
        $file = $workingDir . 'initial_stlist_summary.csv';
        if(Storage::fileExists($file)) {
            $data = trim(Storage::read($file));
            ProjectParameter::insert(['parameter' => 'initial_stlist_summary', 'type' => 'string', 'value' => $data, 'project_id' => $this->id]);
        }


    }

    public function spatialExecute($command) {

        if(is_null($this->_container))
            $this->_container = new spatialContainer($this);

        //dd($this->_container);

        $this->_container->execute($command);

    }






    public function getStListScript() : string {

        $sampleDirs = $this->samples()->pluck('samples.name')->join("/','");
        $sampleDirs = "'" . $sampleDirs . "/'";

        $sampleNames = "'" . $this->samples()->pluck('samples.name')->join("','") . "'";

        $script = "
setwd('/spatialGE')
# Load the package
library('spatialGE')

# Specify paths to directories containing data
count_files = c($sampleDirs)

# Specify sample names
#samplenames = c($sampleNames)
samplenames = 'clinical_data.csv'

# Create STlist
initial_stlist <- STlist(rnacounts=count_files, samples=samplenames)
#initial_stlist <- STlist(rnacounts=count_files, samples=samplenames, spotcoords='segundo archivo csv')

#Save the STList to disk
#save(initial_stlist, file='initial_stlist.RData')
r <- redux::hiredis()
r\$SET('initial_stlist', redux::object_to_bin(initial_stlist))
#r\$HSET('spatialGE', 'initial_stlist', serialize(initial_stlist, NULL))

#Obtain gene names in samples and save it in a text file
gene_names = unique(unlist(lapply(initial_stlist@counts, function(i){ genes_tmp = rownames(i) })))
write.table(gene_names, 'genes.csv',sep=',', row.names = FALSE, col.names=FALSE, quote=FALSE)

# Maximum number of counts per spot
max_spot_counts = max(unlist(lapply(initial_stlist@counts, function(i){  max_tmp = max(Matrix::colSums(i)) })))
write.table(max_spot_counts, 'max_spot_counts.csv',sep=',', row.names = FALSE, col.names=FALSE, quote=FALSE)

# Maximum number of counts per gene
max_gene_counts = max(unlist(lapply(initial_stlist@counts, function(i){ max_tmp = max(Matrix::rowSums(i)) })))
write.table(max_gene_counts, 'max_gene_counts.csv',sep=',', row.names = FALSE, col.names=FALSE, quote=FALSE)

# Maximum number of spots
max_spots_number = max(unlist(lapply(initial_stlist@counts, function(i){ max_tmp = max(ncol(i)) })))
write.table(max_spots_number, 'max_spots_number.csv',sep=',', row.names = FALSE, col.names=FALSE, quote=FALSE)

source('summary.R')
df_summary = summarize_STlist(initial_stlist)
write.csv(df_summary, 'initial_stlist_summary.csv', row.names=FALSE, quote=FALSE)

";

        return $script;

    }


    public function applyFilter($parameters) {

        $workingDir = $this->workingDir();

        $script = $workingDir . 'Filter.R';

        Storage::put($script, $this->getFilterDataScript($parameters));

        $this->spatialExecute('Rscript Filter.R');

        $result = [];

        $file = $workingDir . 'filter_meta_options.csv';
        if(Storage::fileExists($file)) {
            $data = Storage::read($file);
            $options = explode("\n", $data);
            $_options = [];
            foreach ($options as $option)
                if(strlen($option))
                    $_options[] = ['label' => $option, 'value' => $option];
            $json = json_encode($_options);
            ProjectParameter::updateOrCreate(['parameter' => 'filter_meta_options', 'project_id' => $this->id], ['type' => 'json', 'value' => $json]);
            $result['filter_meta_options'] = $json;
        }


        $parameterNames = ['filter_violin', 'filter_boxplot'];
        foreach($parameterNames as $parameterName) {
            $fileName = $parameterName . '.png';
            $file = $workingDir . $fileName;
            $file_public = $this->workingDirPublic() . $fileName;
            if (Storage::fileExists($file)) {
                Storage::copy($file, $file_public);
                ProjectParameter::updateOrCreate(['parameter' => $parameterName, 'project_id' => $this->id], ['type' => 'string', 'value' => $this->workingDirPublicURL() . $fileName]);
                $result[$parameterName] = $this->workingDirPublicURL() . $fileName;
            }
        }

        $parameterName = 'filtered_stlist_summary';
        $file = $workingDir . $parameterName .'.csv';
        if(Storage::fileExists($file)) {
            $data = trim(Storage::read($file));
            ProjectParameter::insert(['parameter' => $parameterName, 'type' => 'string', 'value' => $data, 'project_id' => $this->id]);
            $result[$parameterName] = $data;

        }

        return $result;

    }


    public function getFilterDataScript($parameters) : string {

        $str_params = '';
        foreach ($parameters as $key => $value) {
            if(strlen($value)) {
                $str_params .= strlen($str_params) ? ', ' : '';
                $quote = in_array($key, ['rm_genes_expr', 'spot_pct_expr']) ? "'" : '';
                $str_params .= $key . '=' . $quote . $value . $quote;
            }
        }

        //dd($str_params);

        $script = "
setwd('/spatialGE')
# Load the package
library('spatialGE')

# Load STList from disk
#load(file='initial_stlist.RData')
r <- redux::hiredis()
initial_stlist = redux::bin_to_object(r\$GET('initial_stlist'))

# Apply defined filter to the initial STList
filtered_stlist = filter_data(initial_stlist, $str_params)
#save(filtered_stlist, file='filtered_stlist.RData')
r\$SET('filtered_stlist', redux::object_to_bin(filtered_stlist))

#### Plots Filter Data
# Options for plot
filter_meta_options = unique(unlist(lapply(filtered_stlist@spatial_meta, function(i){ max_tmp = grep(paste0(c('libname', 'xpos', 'ypos'), collapse='|'), colnames(i), value=T, invert=T) })))
write.table(filter_meta_options, 'filter_meta_options.csv',sep=',', row.names = FALSE, col.names=FALSE, quote=FALSE)


source('summary.R')
df_summary = summarize_STlist(filtered_stlist)
write.csv(df_summary, 'filtered_stlist_summary.csv', row.names=FALSE, quote=FALSE)

#### Violin plot
#library('magrittr')
#source('violin_plots.R')
#source('utils.R')
vp = violin_plots(filtered_stlist, plot_meta='total_counts', color_pal='okabeito')
ggpubr::ggexport(filename = 'filter_violin.png', vp, width = 800, height = 800)

#### Box plot
bp = violin_plots(filtered_stlist, plot_meta='total_counts', color_pal='okabeito', plot_type='box')
ggpubr::ggexport(filename = 'filter_boxplot.png', bp, width = 800, height = 800)

";

        //dd($script);

        return $script;

    }





    public function generateFilterPlots($color_palette, $variable) {

        $workingDir = $this->workingDir();

        $scriptName = 'generateFilterPlots.R';

        $script = $workingDir . $scriptName;

        Storage::put($script, $this->getFilterPlotsScript($color_palette, $variable));

        $this->spatialExecute('Rscript ' . $scriptName);

        $parameterNames = ['filter_violin', 'filter_boxplot'];
        foreach($parameterNames as $parameterName) {
            $fileName = $parameterName . '.png';
            $file = $workingDir . $fileName;
            $file_public = $this->workingDirPublic() . $fileName;
            if (Storage::fileExists($file)) {
                Storage::delete($file_public);
                Storage::copy($file, $file_public);
                ProjectParameter::updateOrCreate(['parameter' => $parameterName, 'project_id' => $this->id], ['type' => 'string', 'value' => $this->workingDirPublicURL() . $fileName]);
            }
        }

    }


    public function getFilterPlotsScript($color_palette, $variable) : string {

        $script = "
setwd('/spatialGE')
# Load the package
library('spatialGE')

# Load filtered STList from disk
#load(file='filtered_stlist.RData')
r <- redux::hiredis()
filtered_stlist = redux::bin_to_object(r\$GET('filtered_stlist'))

#### Violin plot
#library('magrittr')
#source('violin_plots.R')
#source('utils.R')
vp = violin_plots(filtered_stlist, plot_meta='$variable', color_pal='$color_palette')
ggpubr::ggexport(filename = 'filter_violin.png', vp, width = 800, height = 800)

#### Box plot
bp = violin_plots(filtered_stlist, plot_meta='$variable', color_pal='$color_palette', plot_type='box')
ggpubr::ggexport(filename = 'filter_boxplot.png', bp, width = 800, height = 800)

";

        return $script;

    }


    public function applyNormalization($parameters) {

        $workingDir = $this->workingDir();

        $scriptName = 'Normalization.R';

        $script = $workingDir . $scriptName;

        Storage::put($script, $this->getNormalizationScript($parameters));

        $this->spatialExecute('Rscript ' . $scriptName);

//        $file = $workingDir . 'filter_meta_options.csv';
//        if(Storage::fileExists($file)) {
//            $data = Storage::read($file);
//            $options = explode("\n", $data);
//            $_options = [];
//            foreach ($options as $option)
//                if(strlen($option))
//                    $_options[] = ['label' => $option, 'value' => $option];
//            ProjectParameter::updateOrCreate(['parameter' => 'filter_meta_options', 'project_id' => $this->id], ['type' => 'json', 'value' => json_encode($_options)]);
//        }


        $result = [];

        $parameterNames = ['normalized_violin', 'normalized_boxplot', 'normalized_boxplot_1', 'normalized_boxplot_2', 'normalized_violin_1', 'normalized_violin_2', 'normalized_density_1', 'normalized_density_2'];
        foreach($parameterNames as $parameterName) {
            $fileName = $parameterName . '.png';
            $file = $workingDir . $fileName;
            $file_public = $this->workingDirPublic() . $fileName;
            if (Storage::fileExists($file)) {
                Storage::delete($file_public);
                Storage::copy($file, $file_public);
                ProjectParameter::updateOrCreate(['parameter' => $parameterName, 'project_id' => $this->id], ['type' => 'string', 'value' => $this->workingDirPublicURL() . $fileName]);
                $result[$parameterName] = $this->workingDirPublicURL() . $fileName;
            }
        }

        $file = $workingDir . 'pca_max_var_genes.csv';
        if(Storage::fileExists($file)) {
            $data = trim(Storage::read($file));
            ProjectParameter::updateOrCreate(['parameter' => 'pca_max_var_genes', 'project_id' => $this->id], ['type' => 'number', 'value' => $data]);
            $result['pca_max_var_genes'] = intval($data);
        }


        return $result;

    }


    public function getNormalizationScript($parameters) : string {

        $str_params = '';
        foreach ($parameters as $key => $value) {
            if(strlen($value)) {
                $str_params .= strlen($str_params) ? ', ' : '';
                $quote = in_array($key, ['method']) ? "'" : '';
                $str_params .= $key . '=' . $quote . $value . $quote;
            }
        }

        //dd($str_params);

        $script = "
setwd('/spatialGE')
# Load the package
library('spatialGE')

# Load filtered STList from disk
#load(file='filtered_stlist.RData')
r <- redux::hiredis()
filtered_stlist = redux::bin_to_object(r\$GET('filtered_stlist'))

normalized_stlist = transform_data(filtered_stlist, $str_params)
r\$SET('normalized_stlist', redux::object_to_bin(normalized_stlist))
#save(normalized_stlist, file='normalized_stlist.RData')

#max_var_genes PCA
pca_max_var_genes = min(unlist(lapply(normalized_stlist@counts, nrow)))
write.table(pca_max_var_genes, 'pca_max_var_genes.csv',sep=',', row.names = FALSE, col.names=FALSE, quote=FALSE)

#### Violin plot
#library('magrittr')
#source('violin_plots.R')
#source('utils.R')
vp = violin_plots(normalized_stlist, color_pal='okabeito', data_type='tr', genes='RPL22')
ggpubr::ggexport(filename = 'normalized_violin.png', vp, width = 800, height = 800)

#### Box plot
bp = violin_plots(normalized_stlist, color_pal='okabeito', plot_type='box', data_type='tr', genes='RPL22')
ggpubr::ggexport(filename = 'normalized_boxplot.png', bp, width = 800, height = 800)



#library('magrittr')
#source('count_distribution.R')
#source('utils.R')
den_raw = count_distribution(normalized_stlist, distrib_subset=0.01, data_type='raw', plot_type=c('density', 'violin', 'box'))
#save(den_raw, './raw_distrib_plots.RData')
#png('./pre_densityplot.png'); print(den_raw\$density); dev.off()
#png('./pre_violinplot.png'); print(den_raw\$violin); dev.off()
#png('./pre_boxplot.png'); print(den_raw\$boxplot); dev.off()
den_tr = count_distribution(normalized_stlist, distrib_subset=0.01, plot_type=c('density', 'violin', 'box'))
#load('./raw_distrib_plots.RData')

#png('./densityplot.png'); print(ggpubr::ggarrange(den_raw\$density, den_tr\$density, ncol=1)); dev.off()
#png('./violinplot.png'); print(ggpubr::ggarrange(den_raw\$violin, den_tr\$violin, ncol=1)); dev.off()
#png('./boxplot.png'); print(ggpubr::ggarrange(den_raw\$boxplot, den_tr\$boxplot, ncol=1)); dev.off()
#ggpubr::ggexport(filename = 'boxplot.png', ggpubr::ggarrange(den_raw\$boxplot, den_tr\$boxplot, ncol=1), width = 800, height = 800)

ggpubr::ggexport(filename = 'normalized_boxplot_1.png', den_raw\$boxplot, width = 800, height = 800)
ggpubr::ggexport(filename = 'normalized_boxplot_2.png', den_tr\$boxplot, width = 800, height = 800)

ggpubr::ggexport(filename = 'normalized_density_1.png', den_raw\$density, width = 800, height = 800)
ggpubr::ggexport(filename = 'normalized_density_2.png', den_tr\$density, width = 800, height = 800)

ggpubr::ggexport(filename = 'normalized_violin_1.png', den_raw\$violin, width = 800, height = 800)
ggpubr::ggexport(filename = 'normalized_violin_2.png', den_tr\$violin, width = 800, height = 800)

";

        //dd($script);

        return $script;

    }


    public function generateNormalizationPlots($color_palette, $gene) {

        $workingDir = $this->workingDir();

        $scriptName = 'generateNormalizedPlots.R';

        $script = $workingDir . $scriptName;

        Storage::put($script, $this->getNormalizedPlotsScript($color_palette, $gene));

        $this->spatialExecute('Rscript ' . $scriptName);

        $parameterNames = ['normalized_violin', 'normalized_boxplot'];
        foreach($parameterNames as $parameterName) {
            $fileName = $parameterName . '.png';
            $file = $workingDir . $fileName;
            $file_public = $this->workingDirPublic() . $fileName;
            if (Storage::fileExists($file)) {
                Storage::delete($file_public);
                Storage::copy($file, $file_public);
                ProjectParameter::updateOrCreate(['parameter' => $parameterName, 'project_id' => $this->id], ['type' => 'string', 'value' => $this->workingDirPublicURL() . $fileName]);
            }
        }

    }


    public function getNormalizedPlotsScript($color_palette, $gene) : string {

        $script = "
setwd('/spatialGE')
# Load the package
library('spatialGE')

# Load normalized STList from disk
#load(file='normalized_stlist.RData')
r <- redux::hiredis()
normalized_stlist = redux::bin_to_object(r\$GET('normalized_stlist'))

#### Violin plot
#library('magrittr')
#source('violin_plots.R')
#source('utils.R')
vp = violin_plots(normalized_stlist, color_pal='$color_palette', data_type='tr', genes='$gene')
ggpubr::ggexport(filename = 'normalized_violin.png', vp, width = 800, height = 800)

#### Box plot
bp = violin_plots(normalized_stlist, color_pal='$color_palette', plot_type='box', data_type='tr', genes='$gene')
ggpubr::ggexport(filename = 'normalized_boxplot.png', bp, width = 800, height = 800)
";

        return $script;

    }


    public function applyPca($plot_meta, $color_pal, $n_genes, $hm_display_genes) {

        $workingDir = $this->workingDir();

        $scriptName = 'generatePca.R';

        $script = $workingDir . $scriptName;

        Storage::put($script, $this->getPcaScript($plot_meta, $color_pal, $n_genes, $hm_display_genes));

        $this->spatialExecute('Rscript ' . $scriptName);

        $result = [];

        $parameterNames = ['pseudo_bulk_pca', 'pseudo_bulk_heatmap'];
        foreach($parameterNames as $parameterName) {
            $fileName = $parameterName . '.svg';
            $file = $workingDir . $fileName;
            $file_public = $this->workingDirPublic() . $fileName;
            if (Storage::fileExists($file)) {
                Storage::delete($file_public);
                Storage::copy($file, $file_public);
                ProjectParameter::updateOrCreate(['parameter' => $parameterName, 'project_id' => $this->id], ['type' => 'string', 'value' => $this->workingDirPublicURL() . $fileName]);
                $result[$parameterName] = $this->workingDirPublicURL() . $fileName;
            }
        }

        return $result;

    }



    public function getPcaScript($plot_meta, $color_pal, $n_genes, $hm_display_genes) : string {

        $export_svgs = '';
        $export_svgs .= "svglite('pseudo_bulk_pca.svg', width = 8, height = 8)\n";
        $export_svgs .= "print(plist\$pca)\n";
        $export_svgs .= "dev.off()\n\n";

        $script = "
setwd('/spatialGE')
# Load the package
library('svglite')
library('spatialGE')

# Load normalized STList from disk
#load(file='normalized_stlist.RData')
r <- redux::hiredis()
normalized_stlist = redux::bin_to_object(r\$GET('normalized_stlist'))


#### Box plot
#pca = pseudobulk_pca(normalized_stlist, plot_meta='$plot_meta', n_genes=$n_genes, color_pal='$color_pal', ptsize=7)

plist = pseudobulk_plots(normalized_stlist, plot_meta='$plot_meta', max_var_genes=$n_genes, hm_display_genes=$hm_display_genes, color_pal='$color_pal', ptsize=5)
#hm_display_genes --> text or slider

ggpubr::ggexport(filename = 'pseudo_bulk_pca.png', plist\$pca, width = 800, height = 800)
ggpubr::ggexport(filename = 'pseudo_bulk_heatmap.png', plist\$heatmap, width = 800, height = 800)

$export_svgs

";

        return $script;

    }


    public function quiltPlot($plot_meta, $color_pal, $sample1, $sample2) {

        $workingDir = $this->workingDir();

        $scriptName = 'quiltPlot.R';

        $script = $workingDir . $scriptName;

        Storage::put($script, $this->getQuiltPlotScript($plot_meta, $color_pal, $sample1, $sample2));

        $this->spatialExecute('Rscript ' . $scriptName);

        $result = [];

        $parameterNames = ['quilt_plot_1', 'quilt_plot_2'];
        foreach($parameterNames as $parameterName) {
            $fileName = $parameterName . '.png';
            $file = $workingDir . $fileName;
            $file_public = $this->workingDirPublic() . $fileName;
            if (Storage::fileExists($file)) {
                Storage::delete($file_public);
                Storage::copy($file, $file_public);
                ProjectParameter::updateOrCreate(['parameter' => $parameterName, 'project_id' => $this->id], ['type' => 'string', 'value' => $this->workingDirPublicURL() . $fileName]);
                $result[$parameterName] = $this->workingDirPublicURL() . $fileName;
            }
        }

        return $result;

    }



    public function getQuiltPlotScript($plot_meta, $color_pal, $sample1, $sample2) : string {

        $script = "
setwd('/spatialGE')
# Load the package
library('spatialGE')

# Load normalized STList from disk
#load(file='normalized_stlist.RData')
r <- redux::hiredis()
normalized_stlist = redux::bin_to_object(r\$GET('normalized_stlist'))

#### Plot
plist1 = STplot(normalized_stlist, samples=c('$sample1'), plot_meta='$plot_meta', color_pal='$color_pal', ptsize=2)
plist2 = STplot(normalized_stlist, samples=c('$sample2'), plot_meta='$plot_meta', color_pal='$color_pal', ptsize=2)
ggpubr::ggexport(filename = 'quilt_plot_1.png', plist1[[1]], width = 800, height = 800)
ggpubr::ggexport(filename = 'quilt_plot_2.png', plist2[[1]], width = 800, height = 800)
";

        return $script;

    }



    public function STplotQuilt($genes, $ptsize, $col_pal, $data_type) {
        $workingDir = $this->workingDir();

        $scriptName = 'STplot-quiltPlot.R';

        $script = $workingDir . $scriptName;

        Storage::put($script, $this->getSTplotQuiltScript($genes, $ptsize, $col_pal, $data_type));

        $this->spatialExecute('Rscript ' . $scriptName);

        $result = [];
        foreach($genes as $gene) {
            $result[$gene] = [];
            foreach ($this->samples as $sample) {
                $parameterName = 'stplot-quilt-' . $gene . '-' . $sample->name;

                $file_extensions = ['svg', 'pdf', 'png'];

                foreach ($file_extensions as $file_extension) {
                    $fileName = $parameterName . '.' . $file_extension;
                    $file = $workingDir . $fileName;
                    $file_public = $this->workingDirPublic() . $fileName;
                    if (Storage::fileExists($file)) {
                        Storage::delete($file_public);
                        Storage::move($file, $file_public);
                        $result[$gene][$sample->name] = $this->workingDirPublicURL() . $parameterName; // $fileName;
                    }
                }

            }
        }

        ProjectParameter::updateOrCreate(['parameter' => 'stplot_quilt', 'project_id' => $this->id], ['type' => 'json', 'value' => json_encode($result)]);

        return json_encode($result);
    }

    public function getSTplotQuiltScript($genes, $ptsize, $col_pal, $data_type) : string {

        $_genes = "c('" . join("','", $genes) . "')";

        $export_files = '';
        foreach ($genes as $gene)
            foreach ($this->samples as $sample)
                $export_files .= $this->getExportFilesCommands("stplot-quilt-$gene-" . $sample->name, "qp\$" . $gene . "_" . $sample->name);

        $script = "

setwd('/spatialGE')
# Load the package
library('spatialGE')
library('svglite')

# Load normalized STList from disk
#load(file='normalized_stlist.RData')
r <- redux::hiredis()
normalized_stlist = redux::bin_to_object(r\$GET('normalized_stlist'))

qp = STplot(normalized_stlist, genes=$_genes, ptsize=$ptsize, color_pal='$col_pal', data_type='$data_type')

$export_files

#/* TODO: *******///
#stlist_expression_surface = gene_interpolation(normalized_stlist, genes=$_genes)
#krp = STplot_interpolation(stlist_expression_surface, genes=$_genes)


";

        return $script;

    }




    public function STplotExpressionSurface($genes, $ptsize, $col_pal, $data_type) {
        $workingDir = $this->workingDir();

        $scriptName = 'STplot-ExpressionSurface.R';

        $script = $workingDir . $scriptName;

        Storage::put($script, $this->getSTplotExpressionSurfaceScript($genes, $ptsize, $col_pal, $data_type));

        $this->spatialExecute('Rscript ' . $scriptName);

        $result = [];
        foreach($genes as $gene) {
            $result[$gene] = [];
            foreach ($this->samples as $sample) {
                $parameterName = 'stplot-expression-surface-' . $gene . '-' . $sample->name;

                $file_extensions = ['svg', 'pdf', 'png'];

                foreach ($file_extensions as $file_extension) {
                    $fileName = $parameterName . '.' . $file_extension;
                    $file = $workingDir . $fileName;
                    $file_public = $this->workingDirPublic() . $fileName;
                    if (Storage::fileExists($file)) {
                        Storage::delete($file_public);
                        Storage::move($file, $file_public);
                        $result[$gene][$sample->name] = $this->workingDirPublicURL() . $parameterName; // $fileName;
                    }
                }

            }
        }

        ProjectParameter::updateOrCreate(['parameter' => 'stplot_expression_surface', 'project_id' => $this->id], ['type' => 'json', 'value' => json_encode($result)]);

        return json_encode($result);
    }

    public function getSTplotExpressionSurfaceScript($genes, $ptsize, $col_pal, $data_type) : string {

        $_genes = "c('" . join("','", $genes) . "')";

        $export_files = '';
        foreach ($genes as $gene)
            foreach ($this->samples as $sample)
                $export_files .= $this->getExportFilesCommands("stplot-expression-surface-$gene-" . $sample->name, "krp\$" . $gene . "_" . $sample->name);

        $script = "

setwd('/spatialGE')
# Load the package
library('spatialGE')
library('svglite')

# Load normalized STList from disk
#load(file='normalized_stlist.RData')
r <- redux::hiredis()
normalized_stlist = redux::bin_to_object(r\$GET('normalized_stlist'))
save(normalized_stlist, file='normalized_stlist.RData')

stlist_expression_surface = gene_interpolation(normalized_stlist, genes=$_genes)
krp = STplot_interpolation(stlist_expression_surface, genes=$_genes, color_pal='$col_pal')

$export_files

";

        return $script;

    }





    private function getExportFilesCommands($file, $plot) : string {

        $str = "if(!is.null($plot)){\n";

        //PNG
        $str .= "ggpubr::ggexport(filename = '$file.png', $plot, width = 800, height = 800)\n";

        //PDF
        $str .= "ggpubr::ggexport(filename = '$file.pdf', $plot, width = 8, height = 8)\n";

        //SVG
        $str .= "svglite('$file.svg', width = 8, height = 8)\n";
        $str .= "print($plot)\n";
        $str .= "dev.off()\n";

        $str .= "}\n\n";

        return $str;
    }






}


